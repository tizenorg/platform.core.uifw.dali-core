<VertexShader>

uniform   mediump mat4    uProjection;
uniform   mediump mat4    uModelView;
uniform   mediump mat4    uMvpMatrix;

uniform           bool    uTextureMapped;
uniform   mediump vec4    uCustomTextureCoords;
attribute highp   vec2    aTexCoord;
varying   mediump vec2    vTexCoord;

uniform   mat3            uModelViewIT;
attribute mediump vec3    aNormal;
varying   mediump vec3    vNormal;

attribute mediump vec3    aPosition;
varying   mediump vec4    vVertex;

#define MAX_BONES_PER_MESH  12

#ifdef USE_BONES
uniform   int             uBoneCount;
uniform   mediump mat4    uBoneMatrices[MAX_BONES_PER_MESH];
uniform   mediump mat3    uBoneMatricesIT[MAX_BONES_PER_MESH];
attribute mediump vec4    aBoneWeights;
attribute mediump vec4    aBoneIndices;
#endif

void main()
{
  mediump vec4 vertexPosition = vec4(aPosition, 1.0);

#ifdef USE_BONES
  if(uBoneCount > 0)
  {
    mediump vec4 boneWeights = aBoneWeights;
    mediump ivec4 boneIndices = ivec4(aBoneIndices);
    mediump vec3 vertexNormal;

    // re-calculate the final weight
    boneWeights.w = 1.0 - dot(boneWeights.xyz, vec3(1.0, 1.0, 1.0));

    mediump vec4 bonePos = (uBoneMatrices[boneIndices.x] * vertexPosition) * boneWeights.x;
    bonePos     += (uBoneMatrices[boneIndices.y] * vertexPosition) * boneWeights.y;
    bonePos     += (uBoneMatrices[boneIndices.z] * vertexPosition) * boneWeights.z;
    bonePos     += (uBoneMatrices[boneIndices.w] * vertexPosition) * boneWeights.w;

    vertexNormal  = (uBoneMatricesIT[boneIndices.x] * aNormal) * boneWeights.x;
    vertexNormal += (uBoneMatricesIT[boneIndices.y] * aNormal) * boneWeights.y;
    vertexNormal += (uBoneMatricesIT[boneIndices.z] * aNormal) * boneWeights.z;
    vertexNormal += (uBoneMatricesIT[boneIndices.w] * aNormal) * boneWeights.w;
    vertexNormal =  normalize(vertexNormal);

    vertexPosition = uProjection * bonePos;
    vVertex = bonePos;
    vNormal = vertexNormal;
  }
  else
  {
#endif
    vertexPosition = uMvpMatrix * vec4(aPosition, 1.0);
    vVertex = uModelView * vec4(aPosition, 1.0);
    vNormal = uModelViewIT * aNormal;
#ifdef USE_BONES
  }
#endif
  gl_Position = vertexPosition;

  mediump vec2 start = uCustomTextureCoords.xy;
  mediump vec2 scale = uCustomTextureCoords.zw;
  vTexCoord = vec2(start.x + aTexCoord.x * scale.x, start.y + aTexCoord.y * scale.y);
}

</VertexShader>

<FragmentShader>

struct Material
{
  mediump float mOpacity;
  mediump float mShininess;
  lowp    vec4  mAmbient;
  lowp    vec4  mDiffuse;
  lowp    vec4  mSpecular;
  lowp    vec4  mEmissive;
};

uniform sampler2D     sTexture;
uniform sampler2D     sOpacityTexture;
uniform sampler2D     sNormalMapTexture;
uniform sampler2D     sEffect;
varying mediump vec2 vTexCoord;

uniform Material      uMaterial;

uniform lowp  vec4    uColor;
varying highp vec4    vVertex;
varying highp vec3    vNormal;

void main()
{
  // sample the texture for the initial color
  mediump vec4 fragColor = texture2D(sTexture, vTexCoord);

  // apply material properties
  fragColor.rgb *= (uMaterial.mAmbient + uMaterial.mDiffuse).rgb;

  // apply material alpha/opacity to alpha channel
  fragColor.a *= uMaterial.mOpacity * uMaterial.mDiffuse.a;

  // and finally, apply Actor color
  fragColor *= uColor;

  gl_FragColor = fragColor;
}

</FragmentShader>
